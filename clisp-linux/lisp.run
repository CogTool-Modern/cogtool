#!/bin/bash

# CogTool Bundled LISP Wrapper Script
# Uses bundled LISP implementations for maximum portability

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Helper functions
log_message() {
    echo "[CogTool LISP] $1" >&2
}

# Try bundled LISP implementations in order of preference
LISP_IMPL=""
LISP_CMD=""

# Check for bundled CLISP
if [ -x "$SCRIPT_DIR/bundle/clisp/bin/clisp" ]; then
    log_message "Using bundled CLISP"
    LISP_IMPL="clisp"
    LISP_CMD="$SCRIPT_DIR/bundle/clisp/bin/clisp"
    export LD_LIBRARY_PATH="$SCRIPT_DIR/bundle/clisp/lib:$LD_LIBRARY_PATH"
# Check for bundled ECL
elif [ -x "$SCRIPT_DIR/bundle/ecl/bin/ecl" ]; then
    log_message "Using bundled ECL"
    LISP_IMPL="ecl"
    LISP_CMD="$SCRIPT_DIR/bundle/ecl/bin/ecl"
    export LD_LIBRARY_PATH="$SCRIPT_DIR/bundle/ecl/lib:$LD_LIBRARY_PATH"
# Check for bundled SBCL
elif [ -x "$SCRIPT_DIR/bundle/sbcl/bin/sbcl" ]; then
    log_message "Using bundled SBCL"
    LISP_IMPL="sbcl"
    LISP_CMD="$SCRIPT_DIR/bundle/sbcl/bin/sbcl"
    export LD_LIBRARY_PATH="$SCRIPT_DIR/bundle/sbcl/lib:$LD_LIBRARY_PATH"
# Fallback to system LISP
elif command -v clisp >/dev/null 2>&1; then
    log_message "Using system CLISP"
    LISP_IMPL="clisp"
    LISP_CMD="clisp"
elif command -v ecl >/dev/null 2>&1; then
    log_message "Using system ECL"
    LISP_IMPL="ecl"
    LISP_CMD="ecl"
elif command -v sbcl >/dev/null 2>&1; then
    log_message "Using system SBCL"
    LISP_IMPL="sbcl"
    LISP_CMD="sbcl"
else
    log_message "ERROR: No LISP implementation found!"
    log_message ""
    log_message "This should not happen as CogTool includes bundled LISP implementations."
    log_message "Please check that the bundle directory exists and contains LISP binaries."
    log_message ""
    exit 1
fi

# Parse command line arguments
QUIET=false
ENCODING=""
MEMORY_IMAGE=""
LOAD_FILES=()
EXECUTE_CMD=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -E|--encoding)
            ENCODING="$2"
            shift 2
            ;;
        -M|--memory-image)
            MEMORY_IMAGE="$2"
            shift 2
            ;;
        -i|--load)
            LOAD_FILES+=("$2")
            shift 2
            ;;
        -x|--execute)
            EXECUTE_CMD="$2"
            shift 2
            ;;
        *)
            # Pass through unknown arguments
            break
            ;;
    esac
done

# Build command based on LISP implementation
if [ "$LISP_IMPL" = "clisp" ]; then
    # CLISP syntax
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD -q"
    fi
    if [ -n "$ENCODING" ]; then
        CMD="$CMD -E $ENCODING"
    fi
    if [ -n "$MEMORY_IMAGE" ]; then
        # Use platform-appropriate memory image or fallback to LISP source
        MEMORY_BASENAME=$(basename "$MEMORY_IMAGE")
        PLATFORM_MEMORY_IMAGE="$SCRIPT_DIR/$MEMORY_BASENAME"
        
        if [ -f "$PLATFORM_MEMORY_IMAGE" ]; then
            log_message "Using platform-specific memory image: $PLATFORM_MEMORY_IMAGE"
            CMD="$CMD -M '$PLATFORM_MEMORY_IMAGE'"
        else
            # Fallback to loading equivalent LISP source file
            LISP_FILE="${MEMORY_IMAGE%.mem}.lisp"
            # Also check in common locations
            if [ ! -f "$LISP_FILE" ]; then
                LISP_FILE="$SCRIPT_DIR/../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
            fi
            if [ ! -f "$LISP_FILE" ]; then
                LISP_FILE="$SCRIPT_DIR/../../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
            fi
            
            if [ -f "$LISP_FILE" ]; then
                log_message "Memory image not available, loading LISP source instead: $LISP_FILE"
                # Change to the directory containing the LISP file for proper relative path resolution
                LISP_DIR=$(dirname "$LISP_FILE")
                LISP_BASENAME=$(basename "$LISP_FILE")
                CMD="cd '$LISP_DIR' && $CMD -i '$LISP_BASENAME'"
            else
                log_message "Warning: Neither memory image nor LISP source found for: $MEMORY_IMAGE"
            fi
        fi
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD -i '$file'"
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD -x '$EXECUTE_CMD'"
    fi
elif [ "$LISP_IMPL" = "ecl" ]; then
    # ECL syntax - memory images not supported, load equivalent LISP file instead
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD -q"
    fi
    # Handle memory image by loading equivalent LISP file
    if [ -n "$MEMORY_IMAGE" ]; then
        # ECL doesn't support memory images, load equivalent LISP source
        LISP_FILE="${MEMORY_IMAGE%.mem}.lisp"
        # Also check in common locations
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        
        if [ -f "$LISP_FILE" ]; then
            log_message "Loading LISP source instead of memory image: $LISP_FILE"
            # Change to the directory containing the LISP file for proper relative path resolution
            LISP_DIR=$(dirname "$LISP_FILE")
            LISP_BASENAME=$(basename "$LISP_FILE")
            CMD="cd '$LISP_DIR' && $CMD --load '$LISP_BASENAME'"
        else
            log_message "Warning: Memory image not supported in ECL, and equivalent LISP file not found: $MEMORY_IMAGE"
        fi
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD --load '$file'"
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD --eval '$EXECUTE_CMD'"
    fi
    # ECL needs explicit quit
    CMD="$CMD --eval '(quit)'"
elif [ "$LISP_IMPL" = "sbcl" ]; then
    # SBCL syntax - memory images not directly supported, load equivalent LISP file
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD --noinform"
    fi
    # Handle memory image by loading equivalent LISP file
    if [ -n "$MEMORY_IMAGE" ]; then
        # SBCL doesn't support CLISP memory images, load equivalent LISP source
        LISP_FILE="${MEMORY_IMAGE%.mem}.lisp"
        # Also check in common locations
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        
        if [ -f "$LISP_FILE" ]; then
            log_message "Loading LISP source instead of memory image: $LISP_FILE"
            # Change to the directory containing the LISP file for proper relative path resolution
            LISP_DIR=$(dirname "$LISP_FILE")
            LISP_BASENAME=$(basename "$LISP_FILE")
            CMD="cd '$LISP_DIR' && $CMD --load '$LISP_BASENAME'"
        else
            log_message "Warning: Memory image not supported in SBCL, and equivalent LISP file not found: $MEMORY_IMAGE"
        fi
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD --load '$file'"
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD --eval '$EXECUTE_CMD'"
    fi
    # SBCL needs explicit quit
    CMD="$CMD --eval '(quit)'"
fi

# Add any remaining arguments
if [[ $# -gt 0 ]]; then
    CMD="$CMD $*"
fi

# Run the command
exec bash -c "$CMD"
