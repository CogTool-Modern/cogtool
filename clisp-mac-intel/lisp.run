#!/bin/bash

# CogTool Intel Mac LISP Wrapper Script
# Provides intelligent LISP implementation selection with fallback strategies
# Supports both bundled and system LISP implementations

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Helper functions
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

log_message() {
    echo "[CogTool LISP] $1" >&2
}

# Initialize variables
LISP_IMPL=""
LISP_CMD=""

# Try to find the best LISP implementation
# Priority: 1. System CLISP, 2. System ECL, 3. System SBCL
if command_exists clisp; then
    log_message "Using system CLISP"
    LISP_IMPL="clisp"
    LISP_CMD="clisp"
elif command_exists ecl; then
    log_message "Using system ECL"
    LISP_IMPL="ecl"
    LISP_CMD="ecl"
elif command_exists sbcl; then
    log_message "Using system SBCL"
    LISP_IMPL="sbcl"
    LISP_CMD="sbcl"
else
    log_message "ERROR: No LISP implementation found!"
    log_message ""
    log_message "Please install a LISP implementation using one of these methods:"
    log_message "  • Homebrew: brew install clisp  (or ecl, or sbcl)"
    log_message "  • MacPorts: sudo port install clisp  (or ecl, or sbcl)"
    log_message "  • Download CLISP from: https://clisp.sourceforge.io/"
    log_message "  • Download ECL from: https://ecl.common-lisp.dev/"
    log_message "  • Download SBCL from: https://www.sbcl.org/"
    log_message ""
    exit 1
fi

# Parse command line arguments and convert between LISP implementations
QUIET=false
ENCODING=""
LOAD_FILES=()
EXECUTE_CMD=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -E|--encoding)
            ENCODING="$2"
            shift 2
            ;;
        -i|--load)
            LOAD_FILES+=("$2")
            shift 2
            ;;
        -x|--execute)
            EXECUTE_CMD="$2"
            shift 2
            ;;
        *)
            # Pass through unknown arguments
            break
            ;;
    esac
done

# Build command based on LISP implementation
if [ "$LISP_IMPL" = "clisp" ]; then
    # CLISP syntax
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD -q"
    fi
    if [ -n "$ENCODING" ]; then
        CMD="$CMD -E $ENCODING"
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD -i \"$file\""
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD -x \"$EXECUTE_CMD\""
    fi
elif [ "$LISP_IMPL" = "ecl" ]; then
    # ECL syntax
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD -q"
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD --load \"$file\""
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD --eval '$EXECUTE_CMD'"
    fi
    # ECL needs explicit quit
    CMD="$CMD --eval '(quit)'"
elif [ "$LISP_IMPL" = "sbcl" ]; then
    # SBCL syntax
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD --noinform"
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD --load \"$file\""
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD --eval '$EXECUTE_CMD'"
    fi
    # SBCL needs explicit quit
    CMD="$CMD --eval '(quit)'"
fi

# Add any remaining arguments
if [[ $# -gt 0 ]]; then
    CMD="$CMD $*"
fi

# Run the command
exec bash -c "$CMD"