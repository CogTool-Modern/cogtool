#!/bin/bash

# CogTool Enhanced Mac LISP Wrapper
# Handles automatic installation and provides comprehensive fallback strategies

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Helper functions
log_message() {
    echo "[CogTool LISP] $1" >&2
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Auto-install function
auto_install_lisp() {
    log_message "No LISP implementation found. Attempting automatic installation..."
    
    if command_exists brew; then
        log_message "Installing ECL via Homebrew..."
        if brew install ecl; then
            log_message "ECL installed successfully!"
            return 0
        else
            log_message "Homebrew installation failed, trying alternative methods..."
        fi
    fi
    
    # If Homebrew fails or isn't available, provide manual instructions
    log_message ""
    log_message "Automatic installation failed. Please install a LISP implementation manually:"
    log_message ""
    log_message "Option 1 - Install Homebrew and ECL (Recommended):"
    log_message "  1. Install Homebrew: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
    log_message "  2. Install ECL: brew install ecl"
    log_message ""
    log_message "Option 2 - Install CLISP:"
    log_message "  • Homebrew: brew install clisp"
    log_message "  • MacPorts: sudo port install clisp"
    log_message "  • Download: https://clisp.sourceforge.io/"
    log_message ""
    log_message "Option 3 - Install SBCL:"
    log_message "  • Homebrew: brew install sbcl"
    log_message "  • Download: https://www.sbcl.org/"
    log_message ""
    return 1
}

# Try to find LISP implementation
LISP_IMPL=""
LISP_CMD=""

# Check bundled implementations first
if [ -x "$SCRIPT_DIR/bundle/ecl/bin/ecl" ]; then
    log_message "Using bundled ECL"
    LISP_IMPL="ecl"
    LISP_CMD="$SCRIPT_DIR/bundle/ecl/bin/ecl"
elif [ -x "$SCRIPT_DIR/bundle/clisp/bin/clisp" ]; then
    log_message "Using bundled CLISP"
    LISP_IMPL="clisp"
    LISP_CMD="$SCRIPT_DIR/bundle/clisp/bin/clisp"
# Check system implementations
elif command_exists ecl; then
    log_message "Using system ECL"
    LISP_IMPL="ecl"
    LISP_CMD="ecl"
elif command_exists clisp; then
    log_message "Using system CLISP"
    LISP_IMPL="clisp"
    LISP_CMD="clisp"
elif command_exists sbcl; then
    log_message "Using system SBCL"
    LISP_IMPL="sbcl"
    LISP_CMD="sbcl"
else
    # Try auto-installation
    if auto_install_lisp; then
        # Retry detection after installation
        if command_exists ecl; then
            log_message "Using newly installed ECL"
            LISP_IMPL="ecl"
            LISP_CMD="ecl"
        elif command_exists clisp; then
            log_message "Using newly installed CLISP"
            LISP_IMPL="clisp"
            LISP_CMD="clisp"
        elif command_exists sbcl; then
            log_message "Using newly installed SBCL"
            LISP_IMPL="sbcl"
            LISP_CMD="sbcl"
        else
            exit 1
        fi
    else
        exit 1
    fi
fi

# Parse command line arguments
QUIET=false
ENCODING=""
MEMORY_IMAGE=""
LOAD_FILES=()
EXECUTE_CMD=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -E|--encoding)
            ENCODING="$2"
            shift 2
            ;;
        -M|--memory-image)
            MEMORY_IMAGE="$2"
            shift 2
            ;;
        -i|--load)
            LOAD_FILES+=("$2")
            shift 2
            ;;
        -x|--execute)
            EXECUTE_CMD="$2"
            shift 2
            ;;
        *)
            # Pass through unknown arguments
            break
            ;;
    esac
done

# Build command based on LISP implementation
if [ "$LISP_IMPL" = "clisp" ]; then
    # CLISP syntax
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD -q"
    fi
    if [ -n "$ENCODING" ]; then
        CMD="$CMD -E $ENCODING"
    fi
    if [ -n "$MEMORY_IMAGE" ]; then
        # Use platform-appropriate memory image or fallback to LISP source
        MEMORY_BASENAME=$(basename "$MEMORY_IMAGE")
        PLATFORM_MEMORY_IMAGE="$SCRIPT_DIR/$MEMORY_BASENAME"
        
        if [ -f "$PLATFORM_MEMORY_IMAGE" ]; then
            log_message "Using platform-specific memory image: $PLATFORM_MEMORY_IMAGE"
            CMD="$CMD -M '$PLATFORM_MEMORY_IMAGE'"
        else
            # Fallback to loading equivalent LISP source file
            LISP_FILE="${MEMORY_IMAGE%.mem}.lisp"
            # Also check in common locations
            if [ ! -f "$LISP_FILE" ]; then
                LISP_FILE="$SCRIPT_DIR/../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
            fi
            if [ ! -f "$LISP_FILE" ]; then
                LISP_FILE="$SCRIPT_DIR/../../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
            fi
            
            if [ -f "$LISP_FILE" ]; then
                log_message "Memory image not available, loading LISP source instead: $LISP_FILE"
                CMD="$CMD -i '$LISP_FILE'"
            else
                log_message "Warning: Neither memory image nor LISP source found for: $MEMORY_IMAGE"
            fi
        fi
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD -i '$file'"
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD -x '$EXECUTE_CMD'"
    fi
elif [ "$LISP_IMPL" = "ecl" ]; then
    # ECL syntax - memory images not supported, load equivalent LISP file instead
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD -q"
    fi
    # Handle memory image by loading equivalent LISP file
    if [ -n "$MEMORY_IMAGE" ]; then
        # ECL doesn't support memory images, load equivalent LISP source
        LISP_FILE="${MEMORY_IMAGE%.mem}.lisp"
        # Also check in common locations
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        
        if [ -f "$LISP_FILE" ]; then
            log_message "Loading LISP source instead of memory image: $LISP_FILE"
            CMD="$CMD --load '$LISP_FILE'"
        else
            log_message "Warning: Memory image not supported in ECL, and equivalent LISP file not found: $MEMORY_IMAGE"
        fi
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD --load '$file'"
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD --eval '$EXECUTE_CMD'"
    fi
    # ECL needs explicit quit
    CMD="$CMD --eval '(quit)'"
elif [ "$LISP_IMPL" = "sbcl" ]; then
    # SBCL syntax - memory images not directly supported, load equivalent LISP file
    CMD="$LISP_CMD"
    if [ "$QUIET" = true ]; then
        CMD="$CMD --noinform"
    fi
    # Handle memory image by loading equivalent LISP file
    if [ -n "$MEMORY_IMAGE" ]; then
        # SBCL doesn't support CLISP memory images, load equivalent LISP source
        LISP_FILE="${MEMORY_IMAGE%.mem}.lisp"
        # Also check in common locations
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        if [ ! -f "$LISP_FILE" ]; then
            LISP_FILE="$SCRIPT_DIR/../../lisp/$(basename "${MEMORY_IMAGE%.mem}").lisp"
        fi
        
        if [ -f "$LISP_FILE" ]; then
            log_message "Loading LISP source instead of memory image: $LISP_FILE"
            CMD="$CMD --load '$LISP_FILE'"
        else
            log_message "Warning: Memory image not supported in SBCL, and equivalent LISP file not found: $MEMORY_IMAGE"
        fi
    fi
    for file in "${LOAD_FILES[@]}"; do
        CMD="$CMD --load '$file'"
    done
    if [ -n "$EXECUTE_CMD" ]; then
        CMD="$CMD --eval '$EXECUTE_CMD'"
    fi
    # SBCL needs explicit quit
    CMD="$CMD --eval '(quit)'"
fi

# Add any remaining arguments
if [[ $# -gt 0 ]]; then
    CMD="$CMD $*"
fi

# Run the command
exec bash -c "$CMD"
